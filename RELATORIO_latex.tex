\documentclass[12pt,a4paper]{report}

% Pacotes essenciais
\usepackage[portuges]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{multirow}
\usepackage{array}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{titling}


\pretitle{\begin{center}\Huge\bfseries\color{blue}} % Título muito grande, em negrito, vermelho
\posttitle{\par\vskip 1em\end{center}} % Espaçamento após o título
\preauthor{\begin{center}\large\itshape\color{black}} % Autor em itálico e azul
\postauthor{\par\end{center}} % Fim da personalização do autor
\predate{\begin{center}\itshape\large} % Estilo antes da data
\postdate{\par\end{center}} % Estilo depois da data

\titleformat{\chapter}
  {\normalfont\bfseries\LARGE\itshape} % Estilo: normal, negrito, tamanho grande, itálico
  {\textcolor{purple}{\thechapter}} % Número do capítulo em roxo
  {2em} % Espaçamento entre número e título
  {} % Sem conteúdo adicional antes
  [] % Sem linha horizontal após o título


% Personalização da seção
\titleformat{\section}
  {\bfseries\Large} % Estilo: negrito, grande
  {\textcolor{red}{\thesection}} % Número da seção em vermelho
  {1em} % Espaçamento entre número e texto
  {} % Sem conteúdo adicional antes
  [\vspace{0.5em}\titlerule] % Linha horizontal abaixo

% Configurações para o código Python
\lstset{
    language=Python,                % Linguagem do código
    basicstyle=\ttfamily\small,     % Fonte básica do código
    keywordstyle=\color{blue},      % Cor para palavras-chave
    stringstyle=\color{red},        % Cor para strings
    commentstyle=\color{green!50!black}, % Cor para comentários
    showstringspaces=false,         % Não mostrar espaços em strings
    numbers=left,                   % Mostrar números de linha na margem esquerda
    numberstyle=\tiny,              % Estilo dos números de linha
    frame=single,                   % Moldura ao redor do código
    breaklines=true,                % Quebrar linhas longas automaticamente
    captionpos=b,                   % Posição da legenda (b para bottom)
}


% Configurações gerais
\parindent=0pt
\parskip=2pt
\setlength{\oddsidemargin}{-1cm}
\setlength{\textwidth}{18cm}
\setlength{\headsep}{-1cm}
\setlength{\textheight}{23cm}
\setlength{\parindent}{1cm} % Ajusta o tamanho da indentação para 1 cm

% Título e autores
\title{Relatório de Desenvolvimento}
\author{Alexis Castro Correia (A102495) \\ João de Albuquerque Ferreira Vieira da Fonseca (A102512)}
\date{\today}

\begin{document}

\maketitle
\begin{abstract}

Este relatório descreve o desenvolvimento de uma linguagem de programação imperativa simples, juntamente com seu compilador correspondente, conforme especificado na declaração do projeto.A linguagem foi projetada para facilitar a declaração de variáveis atômicas inteiras, a execução de operações aritméticas, relacionais e lógicas, bem como instruções de fluxo de controle (seleção e iteração). Além disso, recursos adicionais foram implementados, incluindo a manipulação de arrays unidimensionais ou bidimensionais e a definição e invocação de subprogramas sem parâmetros.

O compilador, criado com o auxílio das ferramentas PLY/Python, traduz o código-fonte escrito nesta linguagem em pseudocódigo e Assembly para execução em uma Máquina Virtual (VM). Este documento engloba a descrição do processo de implementação, exemplos de código na nova linguagem e validação através de casos de teste.
\end{abstract}

\tableofcontents % Insere a tabela de indice
% Capítulos
\chapter{Introdu\c{c}\~{a}o}

Este relatório descreve o processo de concepção e implementação de uma linguagem de programação imperativa simples, bem como o desenvolvimento de um compilador para traduzir programas escritos nessa linguagem para Assembly de uma máquina virtual (VM). Este trabalho foi realizado no contexto da disciplina \emph{Processamento de linguagens e compiladores}, com o objetivo de consolidar os conhecimentos sobre gramáticas formais, construção de compiladores e geração de código Assembly.

A linguagem foi projetada para suportar as principais funcionalidades de linguagens de programação imperativas, incluindo a declaração de variáveis atômicas, manipulação de estruturas de controle de fluxo, execução de operações aritméticas e lógicas, leitura e escrita em \emph{standard input/output}, e a implementação de ciclos. Além disso, foram incorporadas funcionalidades opcionais, como o suporte a \emph{arrays} ou subprogramas, de acordo com os requisitos estabelecidos no enunciado do projeto.

O relatório está organizado da seguinte forma: inicialmente, apresenta-se o contexto e os requisitos para a definição da linguagem e do compilador. Em seguida, detalha-se o processo de construção da gramática independente de contexto (GIC) e a utilização de ferramentas como Yacc/Lex ou PLY/Python. Posteriormente, discute-se a implementação do compilador, incluindo a geração de código Assembly e a execução em uma máquina virtual. Por fim, são apresentados os testes realizados, a análise dos resultados obtidos e as conclusões gerais sobre o trabalho.

Este projeto oferece uma experiência prática em todas as etapas de desenvolvimento de uma linguagem de programação e de um compilador, reforçando conceitos fundamentais da teoria da computação e da engenharia de software.

\chapter{Contextualiza\c{c}\~{a}o}
\section{Descri\c{c}\~{a}o do Problema}
O objetivo deste projeto é criar e implementar instruções simples que permitam aos programadores realizar tarefas simples, como declarar variáveis, executar código, controlar o fluxo de opções e padrões de iteração e ler/escrever dados. Além disso, a linguagem deve incluir recursos adicionais, como suporte para matrizes ou sub-rotinas, para fornecer uma base sólida para a resolução de problemas básicos de computador. É um pseudocódigo e um código assembly que permite que ele seja executado em uma máquina virtual. Portanto, o principal problema é criar um sistema eficaz e eficiente que atenda ao processo de ensino específico e leve em consideração as limitações e características do idioma.
\section{Linguagem}
O nosso grupo decidiu escolher a linguagem C para tradução e compilação neste projeto porque é simples, familiar e atende bem às necessidades do enunciado. A sintaxe da linguagem é simples e fácil de entender, tornando a definição da sintaxe e o compilador fáceis de usar. Além disso, C já é uma linguagem que suporta muitos conceitos como declaração de variáveis, operações aritméticas e aritméticas, expressões de controle de fluxo como if, while, for, que são importantes para os negócios. Assim. Estar familiarizado com C nos ajudará a entender melhor como funciona o processo de conversão de código em código de máquina, o que é importante em nosso trabalho com máquinas virtuais. Resumindo, C fornece uma boa estrutura para processamento simples e eficiente de análise e compilação de linguagem.

\chapter{An\'{a}lisador L\'{e}xico}
Para a resolução do problema construímos o analisador léxico seguindos os seguintes passos

\begin{lstlisting}
    import ply.lex as lex

    literals = ['(' , ')' , '{' , '}', ';' , ',' , '[' , ']', '&']

    tokens = ('ID','CHAR', 'INT', 'FLOAT', 'TIPO',
            'STRING', 'ADD','SUB', 'MUL', 'DIV',
            'EQ', 'NEQ', 'LT', 'LE', 'GT', 'GE',
            'WRITE','READ', 'INCLUDE', 'BIBLIO',
            'IF', 'ELSE', 'FOR', 'WHILE','RETURN',
            'COMENT', 'ATRIBUICAO', 'NOT', 'AND', 'OR')
    
    def t_COMENT(t):
        r'//[^\n]*|(/\*(.*)\*/)'
        return t
        
    def t_BIBLIO(t):
        r'<[A-z0-9][A-z0-9_-]*\.h>'
        return t
        
    def t_ADD(t):
        r'\+'
        return t
        
    def t_SUB(t):
        r'-'
        return t
        
    def t_MUL(t):
        r'\*'
        return t
        
    def t_DIV(t):
        r'/'
        return t
        
    def t_EQ(t):
        r'=='
        return t
        
    def t_NEQ(t):
        r'\!='
        return t
        
    def t_NOT(t):
        r'\!(?!=)'
        return t
        
    def t_LT(t):
        r'<'
        return t
        
    def t_GT(t):
        r'>'
        return t
        
    def t_LE(t):
        r'<='
        return t
        
    def t_GE(t):
        r'>='
        return t
        
    def t_AND(t):
        r'&&'
        return t
        
    def t_OR(t):
        r'\|\|'
        return t
        
    def t_ATRIBUICAO(t):
        r'=(?!=)'
        return t
        
    def t_TIPO(t):
        r'char|int|float|void'
        return t
        
    def t_INCLUDE(t):
        r'\#[ ]?include'
        return t
        
    def t_IF(t):
        r'if'
        return t
        
    def t_ELSE(t):
        r'else'
        return t
        
    def t_FOR(t):
        r'for'
        return t
        
    def t_WHILE(t):
        r'while'
        return t
        
    def t_RETURN(t):
        r'return'
        return t
        
    def t_WRITE(t):
        r'printf'
        return t
        
    def t_READ(t):
        r'scanf'
        return t
        
    def t_CHAR(t):
        r'\"[A-z]\"'
        return t
        
    def t_STRING(t):
        r'\".+\"'
        return t
        
    def t_INT(t):
        r'[0-9]+(?!\.)'
        return t
        
    def t_FLOAT(t):
        r'[0-9]+\.[0-9]+'
        return t
        
    def t_ID(t):
        r'[A-z][A-z0-9_]*'
        return t
        
    t_ignore = ' \n\t'
        
    def t_error(t):
        print('Illegal character: ', t.value[0])
        t.lexer.skip(1)
    
    lexer = lex.lex()

\end{lstlisting}

    Primeiramente impou-se a biblioteca que nos permite criar o analisador léxico,seguida de dois conceitos distintos:
    
    \hspace{1cm}
    \textbf{Literals} $\rightarrow$ São defenidos caracteres específicos ((, ), {, }, ;, ,, [, ],\&,:) que são diretamente reconhecidos como tokens. Esses símbolos são usados frequentemente na linguagem C para delimitação ou controle.
    
    \hspace{1cm}
    \textbf{Tokens} $\rightarrow$ São listados todos os tipos de tokens que o analisador léxico precisa identificar no código C. Cada token representa uma unidade significativa na linguagem, como palavras-chave, operadores, literais e identificadores.

    \hspace{3cm}
    \textbf{ID} $\rightarrow$ Representa identificadores, que são nomes definidos pelo programador para variáveis, funções, ou outros elementos.

    \hspace{3cm}
    \textbf{CHAR} $\rightarrow$ Representa caracteres literais delimitados por aspas simples (').
    
    \hspace{3cm}
    \textbf{INT} $\rightarrow$ Representa números inteiros.

    \hspace{3cm}
    \textbf{FLOAT} $\rightarrow$ Representa números de ponto flutuante.
    
    \hspace{3cm}
    \textbf{TIPO} $\rightarrow$ Representa as palavras-chave de tipo na linguagem C, como int, char e float.

    \hspace{3cm}
    \textbf{STRING} $\rightarrow$ Representa cadeias de caracteres delimitadas por aspas duplas (").

    \hspace{3cm}
    \textbf{ADD} $\rightarrow$ Representa a operação \textcolor{red}{soma}.

    \hspace{3cm}
    \textbf{SUB} $\rightarrow$ Representa a operação \textcolor{red}{subtração}.

    \hspace{3cm}
    \textbf{MUL} $\rightarrow$ Representa a operação \textcolor{red}{multiplicação}.

    \hspace{3cm}
    \textbf{DIV} $\rightarrow$ Representa a operação \textcolor{red}{divisão}.

    \hspace{3cm}
    \textbf{EQ} $\rightarrow$ Representa a comparação \textcolor{red}{igualdade}.

    \hspace{3cm}
    \textbf{NEQ} $\rightarrow$ Representa a comparação \textcolor{red}{diferença}.

    \hspace{3cm}
    \textbf{LT} $\rightarrow$ Representa a comparação \textcolor{red}{menor que}.

    \hspace{3cm}
    \textbf{LE} $\rightarrow$ Representa a comparação \textcolor{red}{menor ou igual}.

    \hspace{3cm}
    \textbf{GT} $\rightarrow$ Representa a comparação \textcolor{red}{maior que}.

    \hspace{3cm}
    \textbf{GE} $\rightarrow$ Representa a comparação maior \textcolor{red}{igual a}.

    \hspace{3cm}
    \textbf{WRITE} $\rightarrow$ Representa a função padrão (em C) \textcolor{red}{write}.

    \hspace{3cm}
    \textbf{READ} $\rightarrow$ Representa a função padrão (em C) \textcolor{red}{read}.

    \hspace{3cm}
    \textbf{INCLUDE} $\rightarrow$ Indica uma inclusão.

    \hspace{3cm}
    \textbf{BIBLIO} $\rightarrow$ Representa bibliotecas padrão(em C).
    
    \hspace{3cm}
    \textbf{IF} $\rightarrow$ Representa a estrutura de controle de fluxo \textcolor{red}{if}.

    \hspace{3cm}
    \textbf{ELSE} $\rightarrow$ Representa a estrutura de controle de fluxo \textcolor{red}{else}.

    \hspace{3cm}
    \textbf{FOR} $\rightarrow$ Representa a estrutura de controle de fluxo \textcolor{red}{for}.

    \hspace{3cm}
    \textbf{WHILE} $\rightarrow$ Representa a estrutura de controle de fluxo \textcolor{red}{while}.

    \hspace{3cm}
    \textbf{RETURN} $\rightarrow$ Representa a estrutura de controle de fluxo \textcolor{red}{return}. 

    \hspace{3cm}
    \textbf{COMENT} $\rightarrow$ Representa comentários no código

    \hspace{3cm}
    \textbf{ATRIBUICAO} $\rightarrow$ Representa o operador de atribuição(=).
    
    \hspace{3cm}
    \textbf{NOT} $\rightarrow$ Representa negação lógica. 

    \hspace{3cm}
    \textbf{AND} $\rightarrow$ Representa \textcolor{red}{e} lógico.

    \hspace{3cm}
    \textbf{OR} $\rightarrow$ Representa \textcolor{red}{ou} lógico.

    Com o analisador léxico pronto temos agora uma base sólida para construir um BNF que represente a linguagem C juntamente com o analisador sintático.
\chapter{An\'{a}lisador Sint\'{a}tico}
\section{BNF}
No desenvolvimento do BNF, nosso objetivo foi criar uma representação simplificada e acessível da linguagem C, que fosse clara e fácil de compreender. Com isso em mente, apresentamos o BNF passo a passo com as respetivas descrições.
\begin{lstlisting}
Programa ::= Imports Funcs
\end{lstlisting}
Representa o programa principal, que consiste em declarações de bibliotecas (Imports) seguidas de funções (Funcs).
\begin{lstlisting}
Imports ::= Import
          | Import Imports 
\end{lstlisting}
Define que o programa pode ter uma ou mais declarações de bibliotecas.
\begin{lstlisting}
Import ::= INCLUDE BIBLIO  
\end{lstlisting}
Define a sintaxe para incluir uma biblioteca
\begin{lstlisting}
Funcs ::= Func
         Func Funcs
\end{lstlisting}
Representa uma ou mais definições de funções no programa.
\begin{lstlisting}
Func ::= Tipo ID '(' ')' '{' Declarations Lines Output '}'
\end{lstlisting}
Define a estrutura de uma função:tipo de retorno (Tipo),nome da função (ID),parâmetros (aqui sem parâmetros definidos),bloco da função com declarações (Declarations), linhas de execução (Lines) e saída (Output).
\begin{lstlisting}
Tipo ::= INTT
       | FLOATT
\end{lstlisting}
Define o tipo de dados da variável ou do retorno de uma função:int ou float.
\begin{lstlisting}
Declarations ::= Declaration
               | Declaration Declarations
\end{lstlisting}
Declara variáveis dentro de um bloco de código
\begin{lstlisting}
Declaration ::= Tipo VarList ';'
              | Tipo ID ATRIBUICAO Expression ';'
\end{lstlisting}
Declara uma lista de variáveis do mesmo tipo ou inicia uma variável com um valor.
\begin{lstlisting}
VarList ::= ID
          | ID ',' VarList 
\end{lstlisting}
Representa uma lista de variáveis separadas por vírgula.
\begin{lstlisting}
Expression ::= Expression ADD Expression
             | Expression SUB Expression
             | Expression MUL Expression
             | Expression DIV Expression
             | '(' <Expression> ')'
             | ID
             | Value
             | Call
\end{lstlisting}
Representa expressões matemáticas e operações que podem ser realizadas(+,-,*,/)
\begin{lstlisting}
Value ::= INT
        | FLOAT
\end{lstlisting}
Representa valores literais numéricos.
\begin{lstlisting}
Call ::= ID '(' ')'
\end{lstlisting}
Representa a chamada de uma função por seu identificador (ID).
\begin{lstlisting}
Lines ::= Line
        | Line Lines
\end{lstlisting}
Representa uma ou mais linhas de execução no corpo de uma função.
\begin{lstlisting}
Line ::= Atribuition
       | Select
       | Cicle
       | Read
       | Write
       | COMENT
\end{lstlisting}
Representa uma única linha de execução(atribuição, seleção (if-else), ciclo (while/for), leitura (Read), escrita (Write), ou comentário (COMENT)).
\begin{lstlisting}
Atribuition ::= ID ATRIBUICAO Expression ';'
\end{lstlisting}
Realiza uma atribuição de valor a uma variável.
\begin{lstlisting}
Select ::= IF '(' Conditions ')' '{' Lines '}' Else
\end{lstlisting}
Define uma estrutura condicional (if-else).
\begin{lstlisting}
Else ::= ELSE '{' Lines '}'
       |
\end{lstlisting}
Bloco opcional que executa quando a condição do if é falsa.
\begin{lstlisting}
Cicle ::= WHILE '(' Conditions ')' '{' Lines '}'
        | FOR '(' ID ATRIBUICAO INT ';' Conditions ';' Math ')' '{' Lines '}'
\end{lstlisting}
Define ciclos (loops) no programa:while ou for.
\begin{lstlisting}
Conditions ::= Condition
             | Condition AND Conditions
             | Condition OR Conditions
\end{lstlisting}
Representa condições lógicas.
\begin{lstlisting}
Condition ::= Expression EQ Expression
            | Expression NEQ Expression
            | Expression LT Expression
            | Expression LE Expression
            | Expression GT Expression
            | Expression GE Expression
            | NOT '(' <Condition> ')'
\end{lstlisting}
Avalia uma expressão lógica
\begin{lstlisting}
Math ::= Atribuition
       | Atribuition ',' Math
\end{lstlisting}
Representa operações matemáticas em ciclos ou expressões.
\begin{lstlisting}
Read ::= READ '(' STRING ',' Addresses ')' ';'
\end{lstlisting}
Lê valores de entrada e os armazena em variáveis.
\begin{lstlisting}
Addresses ::= Address
            | Address ',' Addresses
\end{lstlisting}
Representa uma lista de endereços de memória onde os valores serão armazenados.
\begin{lstlisting}
Address ::= '&' ID
\end{lstlisting}
Representa o endereço de uma variável.
\begin{lstlisting}
Write ::= WRITE '(' STRING ')' ';'
        | WRITE '(' STRING ',' VarList ')' ';'
\end{lstlisting}
Imprime valores na saída padrão.
\begin{lstlisting}
Output ::= RETURN Ret ';'
\end{lstlisting}
Define a instrução de retorno de uma função.
\begin{lstlisting}
Ret ::= ID
      | Value
      | 
\end{lstlisting}
Define o valor retornado pela função, que pode ser uma variável ou um valor literal.


 
Com isto tudo temos o seguinte BNF.

\begin{lstlisting}
Programa ::= Imports Funcs
Imports ::= Import
          | Import Imports
Import ::= INCLUDE BIBLIO
Funcs ::= Func
        | Func Funcs
Func ::= Tipo ID '(' ')' '{' Declarations Lines Output '}'
Tipo ::= INTT
        | FLOATT
Declarations ::= Declaration
               | Declaration Declarations
Declaration ::= Tipo VarList ';'
              | Tipo ID ATRIBUICAO Expression ';'
VarList ::= ID
          | ID ',' VarList
Expression ::= Expression ADD Expression
             | Expression SUB Expression
             | Expression MUL Expression
             | Expression DIV Expression
             | '(' <Expression> ')'
             | ID
             | Value
             | Call
Value ::= INT
        | FLOAT
Call ::= ID '(' ')'
Lines ::= Line
        | Line Lines
Line ::= Atribuition
        | Select
        | Cicle
        | Read
        | Write
        | COMENT
Atribuition ::= ID ATRIBUICAO <Expression> ';'
Select ::= IF '(' <Conditions> ')' '{' <Lines> '}' Else
Else ::= ELSE '{' Lines '}'
       | 
Cicle ::= WHILE '(' Conditions ')' '{' Lines '}'
        | FOR '(' ID ATRIBUICAO INT ';' Conditions ';' Math ')' '{' Lines '}'
Conditions ::= Condition
             | Condition AND Conditions
             | Condition OR Conditions
Condition ::= Expression EQ Expression
             | Expression NEQ Expression
             | Expression LT Expression
             | Expression LE Expression
             | Expression GT Expression
             | Expression GE Expression
             | NOT '(' <Condition> ')'
Math ::= Atribuition
       | Atribuition ',' Math
Read ::= READ '(' STRING ',' <Addresses> ')' ';'
Addresses ::= Address
            | Address ',' Addresses
Address ::= '&' ID
Write ::= WRITE '(' STRING ')' ';'
        | WRITE '(' STRING ',' VarList ')' ';'
Output ::= RETURN Ret ';'
Ret ::= ID
      | Value
      | 
\end{lstlisting}
\section{Máquina Virtual}
De acordo com o enunciado do trabalho, foi nos pedido que fosse gerado um código assembly por isso foi necessario acrescentar certas especificações yacc.



\chapter{Testes e Resultados}
\section{Testes e Resultados}
Resultados dos testes realizados com exemplos.

\chapter{Conclus\~{a}o}
A concepção deste trabalho prático permitiu-nos combinar ideias e técnicas relacionadas com a tecnologia da linguagem na programação gramatical. Implementações de linguagem simples, com suporte a variáveis atômicas, instruções algorítmicas básicas, controle de fluxo e outros recursos adicionais, destacaram desafios e melhores práticas no desenvolvimento de gramáticas de tradução e no uso de ferramentas como Lex e Yacc do PLY.

O pseudocódigo de design e máquina virtual (VM) forneceu uma explicação prática da tradução, destacando a possibilidade de construir e transformar a gramática em uma solução eficaz. A utilização de técnicas e conceitos de processamento de texto não só nos permitiu compreender melhor os conceitos teóricos, mas também aplicá-los de forma eficaz na resolução de problemas práticos. É definida uma linguagem(com base em C) que atenda aos requisitos, incluindo manipulação e métodos básicos de controle. Os documentos LaTeX têm contribuído para a transparência na apresentação dos projetos técnicos, garantindo que os processos e resultados sejam bem documentados e reproduzíveis.

Por fim, o trabalho produzido revelou-se uma experiência de aprendizagem, afirmando as competências técnicas e práticas necessárias para projetos mais complexos. A trabalho desenvolvido, com exemplos práticos, atingiu seus objetivos e apresentou avanços significativos na compreensão e aplicação dos conceitos lecionados nesta unidade curricular.
\end{document}
