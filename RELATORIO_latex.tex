\documentclass[12pt,a4paper]{report}

% Pacotes essenciais
\usepackage[portuges]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{multirow}
\usepackage{array}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{titling}


\pretitle{\begin{center}\Huge\bfseries\color{green}} % Título muito grande, em negrito, vermelho
\posttitle{\par\vskip 1em\end{center}} % Espaçamento após o título
\preauthor{\begin{center}\large\itshape\color{black}} % Autor em itálico e azul
\postauthor{\par\end{center}} % Fim da personalização do autor
\predate{\begin{center}\itshape\large} % Estilo antes da data
\postdate{\par\end{center}} % Estilo depois da data

\titleformat{\chapter}
  {\normalfont\bfseries\LARGE\itshape} % Estilo: normal, negrito, tamanho grande, itálico
  {\textcolor{purple}{\thechapter}} % Número do capítulo em roxo
  {2em} % Espaçamento entre número e título
  {} % Sem conteúdo adicional antes
  [] % Sem linha horizontal após o título


% Personalização da seção
\titleformat{\section}
  {\bfseries\Large} % Estilo: negrito, grande
  {\textcolor{red}{\thesection}} % Número da seção em vermelho
  {1em} % Espaçamento entre número e texto
  {} % Sem conteúdo adicional antes
  [\vspace{0.5em}\titlerule] % Linha horizontal abaixo

% Configurações para o código Python
\lstset{
    language=Python,                % Linguagem do código
    basicstyle=\ttfamily\small,     % Fonte básica do código
    keywordstyle=\color{blue},      % Cor para palavras-chave
    stringstyle=\color{red},        % Cor para strings
    commentstyle=\color{green!50!black}, % Cor para comentários
    showstringspaces=false,         % Não mostrar espaços em strings
    numbers=left,                   % Mostrar números de linha na margem esquerda
    numberstyle=\tiny,              % Estilo dos números de linha
    frame=single,                   % Moldura ao redor do código
    breaklines=true,                % Quebrar linhas longas automaticamente
    captionpos=b,                   % Posição da legenda (b para bottom)
}


% Configurações gerais
\parindent=0pt
\parskip=2pt
\setlength{\oddsidemargin}{-1cm}
\setlength{\textwidth}{18cm}
\setlength{\headsep}{-1cm}
\setlength{\textheight}{23cm}
\setlength{\parindent}{1cm} % Ajusta o tamanho da indentação para 1 cm

% Título e autores
\title{Relatório de Desenvolvimento}
\author{Alexis Castro Correia (A102495) \\ João de Albuquerque Ferreira Vieira da Fonseca (A102512)}
\date{\today}

\begin{document}

\maketitle
\begin{abstract}

Este relatório descreve o desenvolvimento de uma linguagem de programação imperativa simples, juntamente com seu compilador correspondente, conforme especificado na declaração do projeto.A linguagem foi projetada para facilitar a declaração de variáveis atômicas inteiras, a execução de operações aritméticas, relacionais e lógicas, bem como instruções de fluxo de controle (seleção e iteração). Além disso, recursos adicionais foram implementados, incluindo a manipulação de arrays unidimensionais ou bidimensionais e a definição e invocação de subprogramas sem parâmetros.

O compilador, criado com o auxílio das ferramentas PLY/Python, traduz o código-fonte escrito nesta linguagem em pseudocódigo e Assembly para execução em uma Máquina Virtual (VM). Este documento engloba a descrição do processo de implementação, exemplos de código na nova linguagem e validação através de casos de teste.
\end{abstract}

\tableofcontents % Insere a tabela de indice
% Capítulos
\chapter{Introdu\c{c}\~{a}o}

Este relatório descreve o processo de concepção e implementação de uma linguagem de programação imperativa simples, bem como o desenvolvimento de um compilador para traduzir programas escritos nessa linguagem para Assembly de uma máquina virtual (VM). Este trabalho foi realizado no contexto da disciplina \emph{Processamento de linguagens e compiladores}, com o objetivo de consolidar os conhecimentos sobre gramáticas formais, construção de compiladores e geração de código Assembly.

A linguagem foi projetada para suportar as principais funcionalidades de linguagens de programação imperativas, incluindo a declaração de variáveis atômicas, manipulação de estruturas de controle de fluxo, execução de operações aritméticas e lógicas, leitura e escrita em \emph{standard input/output}, e a implementação de ciclos. Além disso, foram incorporadas funcionalidades opcionais, como o suporte a \emph{arrays} ou subprogramas, de acordo com os requisitos estabelecidos no enunciado do projeto.

O relatório está organizado da seguinte forma: inicialmente, apresenta-se o contexto e os requisitos para a definição da linguagem e do compilador. Em seguida, detalha-se o processo de construção da gramática independente de contexto (GIC) e a utilização de ferramentas como Yacc/Lex ou PLY/Python. Posteriormente, discute-se a implementação do compilador, incluindo a geração de código Assembly e a execução em uma máquina virtual. Por fim, são apresentados os testes realizados, a análise dos resultados obtidos e as conclusões gerais sobre o trabalho.

Este projeto oferece uma experiência prática em todas as etapas de desenvolvimento de uma linguagem de programação e de um compilador, reforçando conceitos fundamentais da teoria da computação e da engenharia de software.

\chapter{Contextualiza\c{c}\~{a}o}
\section{Descri\c{c}\~{a}o do Problema}
O objetivo deste projeto é criar e implementar instruções simples que permitam aos programadores realizar tarefas simples, como declarar variáveis, executar código, controlar o fluxo de opções e padrões de iteração e ler/escrever dados. Além disso, a linguagem deve incluir recursos adicionais, como suporte para matrizes ou sub-rotinas, para fornecer uma base sólida para a resolução de problemas básicos de computador. É um pseudocódigo e um código assembly que permite que ele seja executado em uma máquina virtual. Portanto, o principal problema é criar um sistema eficaz e eficiente que atenda ao processo de ensino específico e leve em consideração as limitações e características do idioma.
\section{Linguagem}
O nosso grupo decidiu escolher a linguagem C para tradução e compilação neste projeto porque é simples, familiar e atende bem às necessidades do enunciado. A sintaxe da linguagem é simples e fácil de entender, tornando a definição da sintaxe e o compilador fáceis de usar. Além disso, C já é uma linguagem que suporta muitos conceitos como declaração de variáveis, operações aritméticas e aritméticas, expressões de controle de fluxo como if, while, for, que são importantes para os negócios. Assim. Estar familiarizado com C nos ajudará a entender melhor como funciona o processo de conversão de código em código de máquina, o que é importante em nosso trabalho com máquinas virtuais. Resumindo, C fornece uma boa estrutura para processamento simples e eficiente de análise e compilação de linguagem.

\chapter{An\'{a}lisador L\'{e}xico}
Para a resolução do problema construímos o analisador léxico seguindos os seguintes passos

\begin{lstlisting}
    import ply.lex as lex

    literals = ['(' , ')' , '{' , '}', ';' , ',' , '[' , ']', '&']

    tokens = ('ID','CHAR', 'INT', 'FLOAT', 'TIPO',
            'STRING', 'ADD','SUB', 'MUL', 'DIV',
            'EQ', 'NEQ', 'LT', 'LE', 'GT', 'GE',
            'WRITE','READ', 'INCLUDE', 'BIBLIO',
            'IF', 'ELSE', 'FOR', 'WHILE','RETURN',
            'COMENT', 'ATRIBUICAO', 'NOT', 'AND', 'OR')
    
    def t_COMENT(t):
        r'//[^\n]*|(/\*(.*)\*/)'
        return t
        
    def t_BIBLIO(t):
        r'<[A-z0-9][A-z0-9_-]*\.h>'
        return t
        
    def t_ADD(t):
        r'\+'
        return t
        
    def t_SUB(t):
        r'-'
        return t
        
    def t_MUL(t):
        r'\*'
        return t
        
    def t_DIV(t):
        r'/'
        return t
        
    def t_EQ(t):
        r'=='
        return t
        
    def t_NEQ(t):
        r'\!='
        return t
        
    def t_NOT(t):
        r'\!(?!=)'
        return t
        
    def t_LT(t):
        r'<'
        return t
        
    def t_GT(t):
        r'>'
        return t
        
    def t_LE(t):
        r'<='
        return t
        
    def t_GE(t):
        r'>='
        return t
        
    def t_AND(t):
        r'&&'
        return t
        
    def t_OR(t):
        r'\|\|'
        return t
        
    def t_ATRIBUICAO(t):
        r'=(?!=)'
        return t
        
    def t_TIPO(t):
        r'char|int|float|void'
        return t
        
    def t_INCLUDE(t):
        r'\#[ ]?include'
        return t
        
    def t_IF(t):
        r'if'
        return t
        
    def t_ELSE(t):
        r'else'
        return t
        
    def t_FOR(t):
        r'for'
        return t
        
    def t_WHILE(t):
        r'while'
        return t
        
    def t_RETURN(t):
        r'return'
        return t
        
    def t_WRITE(t):
        r'printf'
        return t
        
    def t_READ(t):
        r'scanf'
        return t
        
    def t_CHAR(t):
        r'\"[A-z]\"'
        return t
        
    def t_STRING(t):
        r'\".+\"'
        return t
        
    def t_INT(t):
        r'[0-9]+(?!\.)'
        return t
        
    def t_FLOAT(t):
        r'[0-9]+\.[0-9]+'
        return t
        
    def t_ID(t):
        r'[A-z][A-z0-9_]*'
        return t
        
    t_ignore = ' \n\t'
        
    def t_error(t):
        print('Illegal character: ', t.value[0])
        t.lexer.skip(1)
    
    lexer = lex.lex()

\end{lstlisting}

    Primeiramente impou-se a biblioteca que nos permite criar o analisador léxico,seguida de dois conceitos distintos:
    
    \hspace{1cm}
    \textbf{Literals} $\rightarrow$ São defenidos caracteres específicos ((, ), {, }, ;, ,, [, ],\&,:) que são diretamente reconhecidos como tokens. Esses símbolos são usados frequentemente na linguagem C para delimitação ou controle.
    
    \hspace{1cm}
    \textbf{Tokens} $\rightarrow$ São listados todos os tipos de tokens que o analisador léxico precisa identificar no código C. Cada token representa uma unidade significativa na linguagem, como palavras-chave, operadores, literais e identificadores.

    \hspace{3cm}
    \textbf{ID} $\rightarrow$ Representa identificadores, que são nomes definidos pelo programador para variáveis, funções, ou outros elementos.

    \hspace{3cm}
    \textbf{CHAR} $\rightarrow$ Representa caracteres literais delimitados por aspas simples (').
    
    \hspace{3cm}
    \textbf{INT} $\rightarrow$ Representa números inteiros.

    \hspace{3cm}
    \textbf{FLOAT} $\rightarrow$ Representa números de ponto flutuante.
    
    \hspace{3cm}
    \textbf{TIPO} $\rightarrow$ Representa as palavras-chave de tipo na linguagem C, como int, char e float.

    \hspace{3cm}
    \textbf{STRING} $\rightarrow$ Representa cadeias de caracteres delimitadas por aspas duplas (").

    \hspace{3cm}
    \textbf{ADD} $\rightarrow$ Representa a operação \textcolor{red}{soma}.

    \hspace{3cm}
    \textbf{SUB} $\rightarrow$ Representa a operação \textcolor{red}{subtração}.

    \hspace{3cm}
    \textbf{MUL} $\rightarrow$ Representa a operação \textcolor{red}{multiplicação}.

    \hspace{3cm}
    \textbf{DIV} $\rightarrow$ Representa a operação \textcolor{red}{divisão}.

    \hspace{3cm}
    \textbf{EQ} $\rightarrow$ Representa a comparação \textcolor{red}{igualdade}.

    \hspace{3cm}
    \textbf{NEQ} $\rightarrow$ Representa a comparação \textcolor{red}{diferença}.

    \hspace{3cm}
    \textbf{LT} $\rightarrow$ Representa a comparação \textcolor{red}{menor que}.

    \hspace{3cm}
    \textbf{LE} $\rightarrow$ Representa a comparação \textcolor{red}{menor ou igual}.

    \hspace{3cm}
    \textbf{GT} $\rightarrow$ Representa a comparação \textcolor{red}{maior que}.

    \hspace{3cm}
    \textbf{GE} $\rightarrow$ Representa a comparação maior \textcolor{red}{igual a}.

    \hspace{3cm}
    \textbf{WRITE} $\rightarrow$ Representa a função padrão (em C) \textcolor{red}{write}.

    \hspace{3cm}
    \textbf{READ} $\rightarrow$ Representa a função padrão (em C) \textcolor{red}{read}.

    \hspace{3cm}
    \textbf{INCLUDE} $\rightarrow$ Indica uma inclusão.

    \hspace{3cm}
    \textbf{BIBLIO} $\rightarrow$ Representa bibliotecas padrão(em C).
    
    \hspace{3cm}
    \textbf{IF} $\rightarrow$ Representa a estrutura de controle de fluxo \textcolor{red}{if}.

    \hspace{3cm}
    \textbf{ELSE} $\rightarrow$ Representa a estrutura de controle de fluxo \textcolor{red}{else}.

    \hspace{3cm}
    \textbf{FOR} $\rightarrow$ Representa a estrutura de controle de fluxo \textcolor{red}{for}.

    \hspace{3cm}
    \textbf{WHILE} $\rightarrow$ Representa a estrutura de controle de fluxo \textcolor{red}{while}.

    \hspace{3cm}
    \textbf{RETURN} $\rightarrow$ Representa a estrutura de controle de fluxo \textcolor{red}{return}. 

    \hspace{3cm}
    \textbf{COMENT} $\rightarrow$ Representa comentários no código

    \hspace{3cm}
    \textbf{ATRIBUICAO} $\rightarrow$ Representa o operador de atribuição(=).
    
    \hspace{3cm}
    \textbf{NOT} $\rightarrow$ Representa negação lógica. 

    \hspace{3cm}
    \textbf{AND} $\rightarrow$ Representa \textcolor{red}{e} lógico.

    \hspace{3cm}
    \textbf{OR} $\rightarrow$ Representa \textcolor{red}{ou} lógico.

    Com o analisador léxico pronto temos agora uma base sólida para construir um BNF que represente a linguagem C juntamente com o analisador sintático.
\chapter{An\'{a}lisador Sint\'{a}tico}
No desenvolvimento do BNF, nosso objetivo foi criar uma representação simplificada e acessível da linguagem C, que fosse clara e fácil de compreender. Com isso em mente, apresentamos o BNF passo a passo.
\begin{lstlisting}
Programa ::= Imports Funcs
\end{lstlisting}
O programa é composto por duas partes principais:

\textbf{Imports} $\rightarrow$ Representa os cabeçalhos de biblioteca importados.

\textbf{Funcs} $\rightarrow$ Contém as funções definidas no programa.
\begin{lstlisting}
Imports ::= Import
          | Import Imports 
\end{lstlisting}
Representa a lista de importações podendo haver uma única importação (Import) ou várias (Import Imports).
\begin{lstlisting}
Import ::= INCLUDE BIBLIO  
\end{lstlisting}

\textbf{INCLUDE} $\rightarrow$ Palavra-chave para inclusão de bibliotecas.

\textbf{BIBLIO} $\rightarrow$ Nome da biblioteca a ser incluída
\begin{lstlisting}
Funcs ::= Func
         Func Funcs
\end{lstlisting}
Representa uma função ou uma sequência de funções
\begin{lstlisting}
Func ::= Tipos ID '(' Params ')' '{' Lines Output '}'
\end{lstlisting}
Cada função tem:

\textbf{Tipos} $\rightarrow$ O tipo de retorno da função (ex.: int, void).

\textbf{ID} $\rightarrow$ O nome da função.

\textbf{Params} $\rightarrow$ Os parâmetros da função, listados entre parênteses.

\textbf{Lines} $\rightarrow$ O corpo da função, composto por várias linhas de código.

\textbf{Output} $\rightarrow$ A declaração de retorno da função (return).
\begin{lstlisting}
Tipos ::= Tipo
        | VOID
Tipo ::= INT
       | CHAR
       | FLOAT
\end{lstlisting}

\textbf{Tipos} $\rightarrow$ Representa os tipos básicos de variáveis podendo ser int.char ou float.         
\begin{lstlisting}
Params ::= Param
         |Param ',' Params
         | 
Param ::= Tipo ID
\end{lstlisting}

\textbf{Params} $\rightarrow$ Lista de parâmetros, podendo ser única (Param) ou múltipla (Param ',' Params).

\textbf{Param} $\rightarrow$ Um parâmetro tem um tipo e um identificador (Tipo ID).
\begin{lstlisting}
Lines ::= Line ';'
        | Line ';' Lines
\end{lstlisting}

\textbf{Lines} $\rightarrow$ Representa o corpo de uma função, que é uma sequência de linhas de código.
\begin{lstlisting}
Line ::= Declaration
       | Atribuition
       | DecAt
       | Math
       | Call
       | Select
       | Cicle
       | Read
       | Write
       | COMENT
\end{lstlisting}
Uma linha pode ser uma declaração, atribuição, chamada de função, estrutura de controle, entre outros.
\begin{lstlisting}
Declaration ::= Tipo VarList
VarList ::= ID Index
          | ID Index ',' VarList
\end{lstlisting}
Para declarar variaveis é necessário o tipo e uma lista de variáveis no qual pode só conter uma única variável (ID Index) ou várias separadas por vírgula.
\begin{lstlisting}
Index ::= '[' INT ']'
        | 
\end{lstlisting}
Representa a indexação de arrays. Pode ser vazia, se a variável não for um array.
\begin{lstlisting}
Atribuition ::= EqList '=' ID Index
              | EqList '=' Value
\end{lstlisting}
Atribui um valor ou outra variável a um identificador.
\begin{lstlisting}
EqList ::= ID Index
         | ID Index '=' EqList
\end{lstlisting}
Representa uma lista de atribuições em cadeia.
\begin{lstlisting}
DecAt ::= Tipo ID '=' ID Index
        | Tipo ID '=' Value
\end{lstlisting}
Essa produção permite declarar uma variável de um determinado tipo e, ao mesmo tempo, atribuir um valor inicial a ela.
\begin{lstlisting}
Values ::= Value
         | Value ',' Values
Value ::= INT
        | FLOAT
        | CHAR
        | Array
Array ::= '{' Values '}'
\end{lstlisting}
Essa produção permite a definição de múltiplos valores, separados por vírgulas do tipo int,float,char e até mesmo um coleção de valores representada por um array.
\begin{lstlisting}
Math ::= ID '=' Expression
\end{lstlisting}
Realiza operações matemáticas e armazena o resultado em uma variável.
\begin{lstlisting}
Expression ::= Expression ADD Expression
             | Expression SUB Expression
             | Expression MUL Expression
             | Expression DIV Expression
             | '(' Expression ')'
             | ID
             | INT
             | FLOAT
\end{lstlisting}
Representa expressões matemáticas, incluindo operações básicas, valores numéricos e variáveis.
\begin{lstlisting}
Call ::= ID '(' Inputs ')'
\end{lstlisting}
Representa a chamada de uma função na linguagem.
\begin{lstlisting}
Inputs ::= Input
        | Input ',' Inputs
\end{lstlisting}
Define os parâmetros ou valores passados para uma função durante sua chamada.
\begin{lstlisting}
Input ::= ID Index
        | Value
\end{lstlisting}
Define os possíveis tipos de argumentos que podem ser passados para uma função.
\begin{lstlisting}
Select ::= IF '(' Conditions ')' '{' Lines '}'
         | IF '(' Conditions ')' '{' Lines '}' ELSE '{' Lines '}'
\end{lstlisting}
Estrutura condicional if-else, que executa blocos de código baseados em condições.
\begin{lstlisting}
Cicle ::= WHILE '(' Conditions ')' '{' Lines '}'
        | FOR '(' ID ATRIBUICAO INT ';' Conditions ';' Maths ')' '{' Lines '}'
\end{lstlisting}
Representa os ciclos while e for, usados para repetir blocos de código.
\begin{lstlisting}
Conditions ::= Condition
             | Condition AND '(' Conditions ')'
             | Condition OR '(' Conditions ')'
\end{lstlisting}
Representa condições lógicas compostas por operadores como AND, OR, e NOT.
\begin{lstlisting}
Condition ::= Expression EQ Expression
            | Expression NEQ Expression
            | Expression LT Expression
            | Expression LE Expression
            | Expression GT Expression
            | Expression GE Expression
            | NOT Condition
\end{lstlisting}
Condições baseadas em operadores de comparação.
\begin{lstlisting}
Maths ::= Math
        | Math ',' Maths
\end{lstlisting}
Lista de operações matemáticas
\begin{lstlisting}
Read ::= READ '(' STRING ',' Addresses ')'
Addresses ::= Address
            | Address ',' Addresses
Address ::= '&' ID
\end{lstlisting}
Este trecho reprensenta a função read e os juntamente com os endereços que esta função requere
\begin{lstlisting}
Write ::= WRITE '(' STRING ')'
        | WRITE '(' STRING ',' Values ')'
\end{lstlisting}
Representa a função write.
\begin{lstlisting}
Output ::= RETURN Ret
Ret ::= ID Index
      | Value
      | 
\end{lstlisting}
Corresponde ao return em C.

 
Com isto tudo temos o seguinte BNF.

\begin{lstlisting}
Programa ::= Imports Funcs
Imports ::= Import
          | Import Imports
Import ::= INCLUDE BIBLIO
Funcs ::= Func
        | Func Funcs
Func ::= Tipos ID '(' Params ')' '{' Lines Output '}'
Tipos ::= Tipo
        | VOID
Tipo ::= INTT
       | CHART
       | FLAOTT
Params ::= Param
         | Param ',' Params
         | 
Param ::= Tipo ID
        | 
Lines ::= Line ';'
        | Line ';' Lines
Line ::= Declaration
       | Atribuition
       | DecAt
       | Math
       | Call
       | Select
       | Cicle
       | Read
       | Write
       | COMENT
Declaration ::= Tipo VarList
VarList ::= ID Index
          | ID Index ',' VarList
Index ::= '[' INT ']'
        | 
Atribuition ::= EqList '=' ID Index
              | EqList '=' Value
EqList ::= ID Index
         | ID Index '=' EqList
DecAt ::= Tipo ID '=' ID Index
        | Tipo ID '=' Value
Values ::= Value
         | Value ',' Values
Value ::= INT
        | FLOAT
        | CHAR
        | Array
Array ::= '{' Values '}'
Math ::= ID '=' Expression
Expression ::= Expression ADD Expression
             | Expression SUB Expression
             | Expression MUL Expression
             | Expression DIV Expression
             | '(' Expression ')'
             | ID
             | INT
             | FLOAT
Call ::= ID '(' Inputs ')'
Inputs ::= Input
         | Input ',' Inputs
Input ::= ID Index
        | Value
Select ::= IF '(' Conditions ')' '{' Lines '}'
         | IF '(' Conditions ')' '{' Lines '}' ELSE '{' Lines '}'
Cicle ::= WHILE '(' Conditions ')' '{' Lines '}'
        | FOR '(' ID ATRIBUICAO INT ';' Conditions ';' Maths ')' '{' Lines '}'
Conditions ::= Condition
             | Condition AND '(' Conditions ')'
             | Condition OR '(' Conditions ')'
Condition ::= Expression EQ Expression
            | Expression NEQ Expression
            | Expression LT Expression
            | Expression LE Expression
            | Expression GT Expression
            | Expression GE Expression
            | NOT Condition
Maths ::= Math
        | Math ',' Maths
Read ::= READ '(' STRING ',' Addresses ')'
Addresses ::= Address
            | Address ',' Addresses
Address ::= '&' ID
Write ::= WRITE '(' STRING ')'
        | WRITE '(' STRING ',' Values ')'
Output ::= RETURN Ret
Ret ::= ID Index
      | Value
      | 
\end{lstlisting}



\chapter{Testes e Resultados}
\section{Testes e Resultados}
Resultados dos testes realizados com exemplos.

\chapter{Conclus\~{a}o}
A concepção deste trabalho prático permitiu-nos combinar ideias e técnicas relacionadas com a tecnologia da linguagem na programação gramatical. Implementações de linguagem simples, com suporte a variáveis atômicas, instruções algorítmicas básicas, controle de fluxo e outros recursos adicionais, destacaram desafios e melhores práticas no desenvolvimento de gramáticas de tradução e no uso de ferramentas como Lex e Yacc do PLY.

O pseudocódigo de design e máquina virtual (VM) forneceu uma explicação prática da tradução, destacando a possibilidade de construir e transformar a gramática em uma solução eficaz. A utilização de técnicas e conceitos de processamento de texto não só nos permitiu compreender melhor os conceitos teóricos, mas também aplicá-los de forma eficaz na resolução de problemas práticos. É definida uma linguagem que atenda aos requisitos, incluindo manipulação e métodos básicos de controle. Os documentos LaTeX têm contribuído para a transparência na apresentação dos projetos técnicos, garantindo que os processos e resultados sejam bem documentados e reproduzíveis.

Por fim, o trabalho produzido revelou-se uma experiência de aprendizagem, afirmando as competências técnicas e práticas necessárias para projetos mais complexos. o futuro. A coleção desenvolvida, com relatos e exemplos de prática, atingiu seus objetivos e apresentou avanços significativos na compreensão e aplicação da linguagem e das habilidades.
\end{document}
